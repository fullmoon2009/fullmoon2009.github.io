---
layout: post
title: "2606 바이러스"
categories: BOJ
tags: BFS
---


## 문제
신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.

예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.
<br><br>


## 입력
첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.
<br><br>


## 출력
1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.
<br><br>


## 아이디어
BFS 문제

그래프 표현  
g = [[] for _ in range(n+1)] 
입력받은 연결 (a,b)를 양쪽에 모두 추가 → 양방향 그래프  
컴퓨터 네트워크 연결은 상호적이므로 a→b와 b→a 둘 다 있어야 함

방문 체크 (vs)  
무한 반복/중복 탐색을 막기 위해 vs 배열 필요  
탐색 시작점인 1번을 True로 두고, 이후 방문한 노드는 다시 큐에 넣지 않음

탐색 (BFS)  
큐에 1번 노드를 넣고 시작  
큐에서 하나씩 꺼내면서 연결된 노드들을 확인.  
아직 방문 안 했다면 vs = True, 카운트 증가, 큐에 추가  
큐가 빌 때까지 반복
<br><br>

## 풀이
```python
import sys
from collections import deque

n = int(sys.stdin.readline())
m = int(sys.stdin.readline())

# 연결 수만큼 빈 리스트 만들기
g = []
for _ in range(n+1):
    g.append([])

for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    g[a].append(b)
    g[b].append(a)

# 리스트 I/O보타 deque가 훨씬 빠름
q = deque([1])
vs = [False] * len(g)
vs[1] = True
cnt = 0

while q:
    current = q.popleft()
    # g의 해당 노드의 원소에 해당하는 vs가 True가 아니면 True로 변경
    for next in g[current]:
        if not vs[next]:
            vs[next] = True
            cnt += 1
            q.append(next)

print(cnt)
```


        

