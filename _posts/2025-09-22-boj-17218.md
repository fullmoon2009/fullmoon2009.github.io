---
layout: post
title: "17218 비밀번호 만들기"
categories: BOJ
tags: LCS(Longest Common Subsequence), DP
---


## 문제
최근 들어 개인정보 유출에 대한 뉴스를 많이 본 수형이는 한 사이트의 비밀번호가 유출 되더라도 다른 사이트에서 똑같은 비밀번호로 접속할 수 없도록 사이트마다 비밀번호를 다르게 설정하기로 다짐했다. 많이 고민한 결과 수형이는 눈을 감고 키보드를 막 쳐서 나온 두 문자열에서 공통으로 존재하는 가장 긴 부분 문자열을 비밀번호로 하기로 하였다. 수형이가 눈을 감고 만든 두 문자열이 주어졌을 때 비밀번호를 만드는 프로그램을 만들어보자.
<br><br>


## 입력
첫째 줄과 둘째 줄에 수형이가 눈을 감고 만든 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 길이는 최대 40자이다. 빈 문자열은 주어지지 않는다. 가장 긴 부분 문자열은 반드시 하나만 존재한다.
<br><br>


## 출력
첫 번째 줄에 입력으로 주어진 두 문자열로 만든 비밀번호를 출력한다.
<br><br>


## 아이디어
LCS, DP 문제  
일반적인 LCS문제와 다른 점은, 길이를 출력하는 것이 아니라 문자열 자체를 출력해야 한다는 것  
따라서 전에 풀었던 1463 1로 만들기 문제와 같이, DP를 이용하여 풀되, 이번에는 2차원 배열과, 이중 반복문을 사용하여 첫 번째 문자열의 i번째 문자와 두 번째 문자열의 j번째 문자가 같으면 dp배열에 저장한다.  
기본적으로 비교 시 두 문자열의 문자가 같으면 기존 문자열에 더하되, 다를 시에는 dp[i-1][j]에 저장된 문자열과 dp[i][j-1]에 저장된 문자열을 비교하여, 더 길이가 긴 것을 dp[i][j]에 저장한다.  
이를 통해 이전 루프에서 쌓인 문자열과, 현재 루프에서 쌓는 중인 문자열의 길이를 비교하여, 더 긴 문자열을 선택해 dp[i][j]에 저장하고, 이후 더해나간다.
<br><br>

## 풀이
```python
import sys

n = sys.stdin.readline().strip()
m = sys.stdin.readline().strip()

dp = [[""] * (len(m)+1) for _ in range(len(n)+1)]


for i in range(1, len(dp)):
    for j in range(1, len(m)+1):
        #문자열의 인덱스는 0부터 시작
        if n[i-1] == m[j-1]:
            dp[i][j] = dp[i-1][j-1] + n[i-1]

        elif len(dp[i-1][j]) > len(dp[i][j-1]):
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = dp[i][j-1]

print(dp[len(n)][len(m)])
```


        

